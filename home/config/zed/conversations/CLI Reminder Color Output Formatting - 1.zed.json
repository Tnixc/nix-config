{"id":"9bc546a8-9f88-4a01-ac86-edce69c71520","zed":"context","version":"0.4.0","text":"\n\n\n```go qr/qr.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/lithammer/fuzzysearch/fuzzy\"\n\t\"github.com/olebedev/when\"\n\t\"github.com/olebedev/when/rules/common\"\n\t\"github.com/olebedev/when/rules/en\"\n)\n\ntype Reminder struct {\n\tID   string\n\tText string\n}\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tprintUsage()\n\t\tos.Exit(1)\n\t}\n\n\tsubcommand := os.Args[1]\n\n\tswitch subcommand {\n\tcase \"l\", \"list\":\n\t\tlistReminders()\n\tcase \"a\", \"add\":\n\t\tif len(os.Args) < 3 {\n\t\t\tfmt.Println(\"Error: No reminder text provided\")\n\t\t\tprintUsage()\n\t\t\tos.Exit(1)\n\t\t}\n\t\treminderText := strings.Join(os.Args[2:], \" \")\n\t\taddReminder(reminderText)\n\tcase \"r\", \"remove\":\n\t\tif len(os.Args) < 3 {\n\t\t\tfmt.Println(\"Error: No reminder index or text provided\")\n\t\t\tprintUsage()\n\t\t\tos.Exit(1)\n\t\t}\n\t\ttarget := strings.Join(os.Args[2:], \" \")\n\t\tremoveReminder(target)\n\tdefault:\n\t\tfmt.Printf(\"Unknown subcommand: %s\\n\", subcommand)\n\t\tprintUsage()\n\t\tos.Exit(1)\n\t}\n}\n\nfunc listReminders() {\n\tcmd := exec.Command(\"reminders\", \"show\", \"Sooner\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\tif err := cmd.Run(); err != nil {\n\t\tfmt.Printf(\"Error listing reminders: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc addReminder(text string) {\n\t// Parse date and time from the text\n\tw := when.New(nil)\n\tw.Add(en.All...)\n\tw.Add(common.All...)\n\n\tnow := time.Now()\n\tresult, err := w.Parse(text, now)\n\n\tvar reminderCmd *exec.Cmd\n\n\tif err != nil || result == nil {\n\t\t// No date/time found, add as a regular reminder\n\t\treminderCmd = exec.Command(\"reminders\", \"add\", \"Sooner\", text)\n\t} else {\n\t\t// Extract the date/time and the actual reminder text\n\t\tdateTime := result.Time.Format(\"2006-01-02 15:04:05\")\n\n\t\t// Remove the date/time part from the reminder text\n\t\tcleanText := text[:result.Index] + text[result.Index+len(result.Text):]\n\t\tcleanText = strings.TrimSpace(cleanText)\n\n\t\t// If the text is empty after removing the date, use a generic message\n\t\tif cleanText == \"\" {\n\t\t\tcleanText = \"Reminder\"\n\t\t}\n\n\t\t// Add reminder with the specified date and time\n\t\treminderCmd = exec.Command(\"reminders\", \"add\", \"Sooner\", cleanText, \"-d\", dateTime)\n\t}\n\n\treminderCmd.Stdout = os.Stdout\n\treminderCmd.Stderr = os.Stderr\n\n\tif err := reminderCmd.Run(); err != nil {\n\t\tfmt.Printf(\"Error adding reminder: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc removeReminder(target string) {\n\t// Get the list of reminders\n\treminders, err := getReminders()\n\tif err != nil {\n\t\tfmt.Printf(\"Error getting reminders: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif len(reminders) == 0 {\n\t\tfmt.Println(\"No reminders found\")\n\t\treturn\n\t}\n\n\t// Check if target is a number (index)\n\tif index, err := strconv.Atoi(target); err == nil {\n\t\tif index >= 0 && index < len(reminders) {\n\t\t\t// Valid index, remove the reminder\n\t\t\tremoveReminderByID(reminders[index].ID)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Invalid index: %d. Valid range is 0-%d\\n\", index, len(reminders)-1)\n\t\treturn\n\t}\n\n\t// Target is not a number, try to find the closest match\n\tbestMatch := \"\"\n\tbestScore := 0.0\n\tbestIndex := -1\n\n\n\tfor i, reminder := range reminders {\n    // Calculate similarity score using fuzzy matching\n    distance := fuzzy.LevenshteinDistance(target, reminder.Text)\n    maxLen := float64(max(len(target), len(reminder.Text)))\n    normalizedScore := 1.0 - (float64(distance) / maxLen)\n\n    if normalizedScore > bestScore {\n        bestScore = normalizedScore\n        bestMatch = reminder.Text\n        bestIndex = i\n    }\n}\n\n\t// If the best match is less than 75% similar, discard it\n\tif bestScore < 0.75 {\n\t\tfmt.Printf(\"No reminder found matching '%s' with at least 75%% similarity\\n\", target)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Removing reminder: %s (%.0f%% match)\\n\", bestMatch, bestScore*100)\n\tremoveReminderByID(reminders[bestIndex].ID)\n}\n\nfunc getReminders() ([]Reminder, error) {\n\tcmd := exec.Command(\"reminders\", \"show\", \"Sooner\")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\tcmd.Stderr = os.Stderr\n\n\tif err := cmd.Run(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the output to extract reminders\n\tvar reminders []Reminder\n\tscanner := bufio.NewScanner(&out)\n\n\t// Regular expression to match reminder lines with IDs\n\t// This regex pattern might need adjustment based on the actual output format\n\tre := regexp.MustCompile(`^(\\d+): (.+?)( \\(in .+\\))?$`)\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tmatches := re.FindStringSubmatch(line)\n\t\tif len(matches) >= 3 {\n\t\t\treminders = append(reminders, Reminder{\n\t\t\t\tID:   matches[1],\n\t\t\t\tText: strings.TrimSuffix(matches[2], \" \"),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn reminders, nil\n}\n\nfunc removeReminderByID(id string) {\n\tcmd := exec.Command(\"reminders\", \"delete\", \"Sooner\", id)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\tif err := cmd.Run(); err != nil {\n\t\tfmt.Printf(\"Error removing reminder: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc printUsage() {\n\tfmt.Println(\"Usage:\")\n\tfmt.Println(\"  qr l|list                                List all reminders\")\n\tfmt.Println(\"  qr a|add <reminder text> [date/time]     Add a new reminder\")\n\tfmt.Println(\"  qr r|remove <index|text>                 Remove a reminder by index or text\")\n\tfmt.Println(\"\")\n\tfmt.Println(\"Examples:\")\n\tfmt.Println(\"  qr a Buy groceries\")\n\tfmt.Println(\"  qr a Call mom tomorrow at 5pm\")\n\tfmt.Println(\"  qr r 2                                   Remove reminder at index 2\")\n\tfmt.Println(\"  qr r Buy groceries                       Remove reminder matching text\")\n}\n```\n\n\n>go run . l\n0: Read the claude thinking paper \n1: Fix dynOG on tnixc.space\n2: 2025 Q1 Review (in 1 day)\n3: Beta-oxidation of fatty acids (in 8 hours)\n4: Amino acid catabolism (in 8 hours)\n5: Anaerobic metabolism (in 8 hours)\n\n>go run . a 'hello'\nAdded 'hello' to 'Sooner'\n\nAdd color to the output. Parse the output. The 0: should be turned into [0] and be in yellow, with the brackets in gray. parse the (in 1 day) section and make that bold blue. (parse it by searching for ( from the end). Make the brackets gray.\n\nThe output Added 'hello' to 'Sooner', turn 'Sooner' to bold yellow, 'hello' (the item) to bold green. The quotes themselves should be gray.\nHere's how you can modify the code to add color using ANSI escape codes. You'll need to add these color constants at the top of the file and modify the output handling:\n\n```go\nconst (\n    gray   = \"\\033[38;5;242m\"\n    yellow = \"\\033[33m\"\n    blue   = \"\\033[1;34m\"\n    green  = \"\\033[1;32m\"\n    bold   = \"\\033[1m\"\n    reset  = \"\\033[0m\"\n)\n\nfunc listReminders() {\n    cmd := exec.Command(\"reminders\", \"show\", \"Sooner\")\n    var out bytes.Buffer\n    cmd.Stdout = &out\n    cmd.Stderr = os.Stderr\n\n    if err := cmd.Run(); err != nil {\n        fmt.Printf(\"Error listing reminders: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    scanner := bufio.NewScanner(&out)\n    for scanner.Scan() {\n        line := scanner.Text()\n        \n        // Split by colon to separate index and content\n        parts := strings.SplitN(line, \":\", 2)\n        if len(parts) != 2 {\n            continue\n        }\n        \n        index := strings.TrimSpace(parts[0])\n        content := strings.TrimSpace(parts[1])\n        \n        // Check for time indication at the end\n        timeInd := \"\"\n        if idx := strings.LastIndex(content, \"(\"); idx != -1 {\n            timeInd = content[idx:]\n            content = strings.TrimSpace(content[:idx])\n        }\n        \n        // Format the output with colors\n        fmt.Printf(\"%s[%s%s%s]%s %s\", gray, yellow, index, gray, reset, content)\n        \n        if timeInd != \"\" {\n            timeText := timeInd[1 : len(timeInd)-1] // remove parentheses\n            fmt.Printf(\" %s(%s%s%s)%s\", gray, blue, timeText, gray, reset)\n        }\n        fmt.Println()\n    }\n}\n\nfunc addReminder(text string) {\n    // ... existing code ...\n\n    if err := reminderCmd.Run(); err != nil {\n        fmt.Printf(\"Error adding reminder: %v\\n\", err)\n        os.Exit(1)\n    } else {\n        fmt.Printf(\"Added %s'%s'%s to %s'Sooner'%s\\n\",\n            gray, green+text+gray,\n            reset,\n            yellow+bold, reset)\n    }\n}\n```\n\nThis will produce colored output like:\n\n```\n[0] Read the claude thinking paper\n[1] Fix dynOG on tnixc.space\n[2] 2025 Q1 Review (in 1 day)\n[3] Beta-oxidation of fatty acids (in 8 hours)\n[4] Amino acid catabolism (in 8 hours)\n[5] Anaerobic metabolism (in 8 hours)\n```\n\nAnd for adding reminders:\n```\nAdded 'hello' to 'Sooner'\n```\n\nWhere:\n- The brackets and numbers are gray and yellow respectively\n- The time indications are in bold blue with gray parentheses\n- For the add confirmation, the quotes are gray, the item is bold green, and 'Sooner' is bold yellow\n\nNote: The actual colors may vary slightly depending on your terminal's color scheme.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":111}}},{"id":{"replica_id":0,"value":99},"start":6037,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":112}}},{"id":{"replica_id":0,"value":100},"start":8609,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":113}}}],"summary":"CLI Reminder Color Output Formatting","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":5378},"icon":"File","label":"qr/qr.go","metadata":{"path":"qr/qr.go"}}],"thought_process_output_sections":[]}